// npm run generate-rpc-errors-file

import { JSDOM } from 'jsdom';
import fetch from 'node-fetch';
import fs from 'fs';

let FINISHED = false;

async function main() {
  const response = await fetch('http://tezos.gitlab.io/api/errors.html');
  const html = await response.text();
  const { window } = new JSDOM(html);
  const document = window.document;

  const results = Array.from(document.querySelectorAll('#rpc-errors .section'))
    .flatMap((section) =>
      Array.from(section.querySelectorAll('.tabcontent'))
        .filter((tab, i) => i % 2 === 0)
        .map((c) => {
          const key = Array.from(c.querySelectorAll('i'))
            .find((p) => p.innerHTML.includes('Id'))
            .nextSibling.textContent.replace(/:/g, '')
            .trim();
          const category = Array.from(c.querySelectorAll('i'))
            .find((p) => p.innerHTML.includes('Category'))
            .nextSibling.textContent.replace(/:/g, '')
            .trim();
          const msg = Array.from(c.querySelectorAll('p'))[0]
            .textContent.replace(/[\n\r]/g, '')
            .replace(/[ ]{2,}/g, ' ');
          return {
            key,
            value: {
              msg,
              category
            }
          };
        })
    )
    .reduce((obj, item) => ((obj[item.key] = item.value), obj), {});

  const date = new Date();
  const year = date.getFullYear();
  const month = `0${date.getMonth() + 1}`.slice(-2);
  const day = `0${date.getDate()}`.slice(-2);
  const formattedDate = `${year}-${month}-${day}`;

  output = `/* eslint-disable */
// Last updated on: ${formattedDate}
// Inform users of the most common errors
// generated by scripts/generate-rpc-errors-file.ts
// source: http://tezos.gitlab.io/api/errors.html

interface RPCError {
  msg: string;
  category: string;
}

export const rpcErrors: Record<string, RPCError> =
`;
  output += JSON.stringify(results, undefined, 2);
  output += ';';

  fs.writeFileSync('./src/app/services/error-handling/rpc-errors.ts', output);

  FINISHED = true;
}

function wait() {
  if (!FINISHED) {
    setTimeout(wait, 1000);
  }
}

main();
wait();

export {};
